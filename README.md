# Reinforce

Have you ever wanted to implement reinforcement learing algorithms in C++, but did not want to leave the trusted API
of Python equivalents?
No? Oh...

Well, `Reinforce` is a C++ implementation of the Gymnasium spaces anyway, designed to bridge the use of
Reinforcement Learning (RL) in C++. Its aim is to port existing spaces, wherever meaningful, and related features
of [Gymnasium](https://github.com/Farama-Foundation/Gymnasium), allowing developers to squeeze the
last drop of performance out of their training routines.

## Features

- **Gym Spaces:** Reinforce provides C++ implementations of common Gymnasium spaces whenever meaningful. For a seamless
  transition from the Python-based standard set by Gym their API is replicated as much as possible.
  All spaces implemented so far provide the basic public API:
    - (vectorized) `sampling`
    - `contains` checks
    - `repr`
    - `equality` comparison .

  The following spaces have already been ported:
    - `Discrete`
    - `Box`
    - `Graph`
    - `MultiDiscrete`
    - `MultiBinary`
    - `Text`
    - `Tuple`
    - `Sequence`

- **XTensor:** Reinforce uses [xtensor](https://github.com/xtensor-stack/xtensor) as its efficient tensor
  operations backbone. This allows for speedy computation of the data generated by the Gym spaces. The
  standard `xtensor` API (
  see [xtensor-docs](https://xtensor.readthedocs.io/en/latest/)) which is designed to resemble the
  NumPy API as much as possible can be used to interact with samples of most of the spaces.
- **Environments:** Reinforce plans to offer a small selection of environments for training RL models.
  Currently, only a version of `gridworld` of arbitrary dimensions is included.

## Examples

### Sampling From Box Space.

<table>
<tr>
<th>Reinforce</th>
<th>Gymnasium</th>
</tr>
<tr>
<td>

```cpp
#include <reinforce/spaces/box.hpp>
#include <reinforce/utils/math.hpp>

using namespace force;

// high and low boundaries for samples 
// of shape (2,3). We have that 
// low[i,j] <= samples[:, i,j] <= high[i,j]
xarray< double > low {{-inf<>,  0,    -4},
                      {     4, 16,    64}};
xarray< double > high{{ inf<>,  2,    -2},
                      {     8, 32, inf<>}};
auto space = BoxSpace{low, high};

xt::print_options::set_precision(1);
// sample either a single sample
fmt::println("Sample:\n{}", space.sample());

// or a batch of samples
fmt::println(
  "Batch:\n{}", 
  space.sample(100)
);
```

</td>
<td>

```python
import numpy as np
import gymnasium as gym

# high and low boundaries for samples
# of shape (2,3). We have that
# low[i,j] <= samples[:, i,j] <= high[i,j]
low = np.array([[-np.inf, 0, -4],
                [4, 16, 64]],
               dtype=float)
high = np.array([[np.inf, 2, -2],
                 [8, 32, np.inf]],
                dtype=float);
space = gym.spaces.Box(low, high)

with np.printoptions(precision=2):
    # sample either a single sample
    print(f"Sample:\n{space.sample()}")

    # or a batch of samples
    print(f"Sample batch:\n{np.vstack([
      space.sample().reshape(1, 2, 3)
      for _ in range(100)
    ])}")
```

</td>
</tr>

<tr>
<td>

```
Sample:
{{  1.3,   0.1,  -3. },
 {  6.9,  22.6,  64.4}}
Sample batch:
{{{ -1.6,   0.6,  -2.3},
  {  7.8,  29.3,  64.7}},
  
 {{ -0.3,   0.7,  -3.6},
  {  6.8,  27.4,  64.1}},
  
 {{  1.3,   1. ,  -3.7},
  {  5.3,  23.4,  64.2}},
  
 ...,
 
 {{ -0.1,   0.5,  -2.2},
  {  4.9,  24.8,  64. }},
  
 {{  0. ,   0.7,  -2. },
  {  7.5,  16.3,  64.8}},
  
 {{ -1. ,   0.9,  -3.4},
  {  5.5,  25.7,  64.1}}}
```

</td>
<td>

```
Sample:
[[-1.2  1.6 -2.1]
 [ 5.6 28.1 64.9]]
Sample batch:
[[[ 0.4  1.5 -3.4]
  [ 7.7 29.1 64.3]]

 [[-1.   0.4 -3.8]
  [ 4.8 24.  64.1]]

 [[-0.5  1.9 -2.2]
  [ 5.1 22.3 65.3]]

 ...

 [[ 0.5  1.3 -3.4]
  [ 4.2 25.3 64.8]]

 [[-1.6  0.5 -3.8]
  [ 5.9 23.4 64. ]]

 [[ 1.1  1.8 -2.3]
  [ 5.2 29.2 64. ]]]
```

</td>
</tr>
</table>

## Getting Started

This project relies on several dependencies to function correctly:

- **CMake**, a cross-platform open-source build system generator.

- **Conan**, a C/C++ package manager.

The specific dependencies for the code to function are listed in the `conandata.yml` file. Conan will handle the
installation of these.

To install cmake/conan, you can use the following commands:

```bash
sudo apt-get install cmake
pip install conan
```

Please note that these commands are for Ubuntu. If you're using a different operating system, please adjust the commands
accordingly.

After installing Conan, you can install the project-specific dependencies by running:

```bash
conan install .
```

This command needs to be run in the project directory and will install all the necessary dependencies listed in
the `conandata.yml` file.
Alternatively, using the provided `configure.sh` and `build.sh` scripts will handle the conan installation and cmake
configuration automatically; by default, it will configure a build folder named `build` in the project root. To get
started with this, clone the repository and build it by running the following commands:

```bash
git clone https://github.com/maichmueller/reinforce.git
cd reinforce
./configure.sh
./build.sh
```

After building the project, you can start install it by running:

```bash
./install.sh
```

## Documentation

As of now, the documentation is still a work in progress. However, the test files under `tests` showcase basic usage.

## Contributing

Contributions to Reinforce are welcome. Please make sure to read the contributing guide before making a pull request.

## License

Reinforce is licensed under the MIT License. See `LICENSE` for more information.

## Contact

If you have any questions or suggestions, please open an issue on GitHub.
